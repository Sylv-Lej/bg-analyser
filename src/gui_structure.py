import cv2import imutilsTHRESH_DIFF_HORIZONTAL = 15THRESH_DIFF_BAR = 10class BackGamonIMG:    def __init__(self, img = None):        scale_factor = 1.41        self.debug_img = img        stride_factor = 69        stride_factor_bot = 72        self.fleche_list = []        for i in range(6):            # original stride            # stride = int(71 / scale_factor)            stride = int(stride_factor_bot / scale_factor)            max_x = int(1012 / scale_factor)            pos = max_x - i * stride            self.fleche_list.append(Position(pos, int(850/ scale_factor)))                for i in range(6):            stride = int(stride_factor_bot / scale_factor)            max_x = int(494 / scale_factor)            pos = max_x - i * stride            self.fleche_list.append(Position(pos, int(850/ scale_factor)))                # top         for i in range(6):            stride = int(stride_factor / scale_factor)            min_x = int(139 / scale_factor)            pos = min_x + i * stride            self.fleche_list.append(Position(pos, int(44/ scale_factor)))                    for i in range(6):            stride = int(stride_factor / scale_factor)            max_x = int(657 / scale_factor)            pos = max_x + i * stride            self.fleche_list.append(Position(pos, int(44/ scale_factor)))    def set_debug_img(self, img):        self.debug_img = img    def set_bar_position(self, largeur, hauteur):        self.bar_position_x = int(largeur/2)        self.bar_position_y = int(hauteur/2)    def debug_by_img(self):        debug_dice = True        if(self.debug_img is not None):            for i in self.fleche_list:                cv2.circle(self.debug_img, (i.x, i.y), 5, (255, 255, 0), int(THRESH_DIFF_HORIZONTAL/2))            # cv2.circle(self.debug_img, (self.bar_position_x , self.bar_position_y), 5, (255, 0, 255), 3)            # font = cv2.FONT_HERSHEY_SIMPLEX            # color = (255, 0, 0)            # overlay = self.debug_img.copy()            # cv2.rectangle(overlay, (30, 30), (90, 90), (0,0,0), -1)            if(debug_dice):                cv2.imshow("debug dice", self.debug_dice_img)                cv2.waitKey(0)                                # cv2.imshow("debug debug_left_img", self.debug_left_img)                # cv2.imshow("debug debug_right_img", self.debug_right_img)                # cv2.waitKey(0)                print("debug dice")            cv2.putText(self.debug_img,"Dices : {} and {}".format(self.left_dice_value,self.right_dice_value),                        (self.bar_position_x + 50, self.bar_position_y + 50),                        2, 1, 70)            cv2.imshow("debug img", self.debug_img)            cv2.waitKey(0)    def debug(self):        for fl in range(len(self.fleche_list)):            print(self.fleche_list[fl])    def getDiceValue(self, dice_frame):        import numpy as np        dice_frame = imutils.resize(dice_frame, width=dice_frame.shape[0]*4)        blurred = cv2.GaussianBlur(dice_frame, (7, 7), 0)        # hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)        ret, thresholded_img = cv2.threshold(blurred, 128, 255, cv2.THRESH_BINARY)        thresholded_img = thresholded_img[:,:,2:]        detected_circles = cv2.HoughCircles(thresholded_img, cv2.HOUGH_GRADIENT, 1, 20, param1=15, param2=12, minRadius=1, maxRadius=50)        if detected_circles is not None:            # Convert the circle parameters a, b and r to integers.             detected_circles = np.uint16(np.around(detected_circles))             for pt in detected_circles[0, :]:                 a, b, r = pt[0], pt[1], pt[2]                cv2.circle(dice_frame, (a, b), r, (0, 255, 0), 1)        # cv2.imshow("debug circle", dice_frame)        # cv2.waitKey(0)        if(detected_circles is not None):            return len(detected_circles[0])        else:            return None    def setDiceTuple(self, dices_frame):        self.debug_dice_img = dices_frame.copy()        left_dice = dices_frame[:, 0:int(dices_frame.shape[1]/2)]        right_dice = dices_frame[:, int(dices_frame.shape[1]/2):dices_frame.shape[1]]        self.debug_left_img = left_dice.copy()        self.debug_right_img = right_dice.copy()        self.left_dice_value = self.getDiceValue(left_dice)        self.right_dice_value = self.getDiceValue(right_dice)    def getDiceTuple(self):        return self.left_dice_value, self.right_dice_value    def getFlechePlusPres(self, center_analysed, vertical_side):        diff_bar = abs(center_analysed - self.bar_position_x)        if(diff_bar < THRESH_DIFF_BAR):            return -1        if(vertical_side == 'top'):            fleche_id = 13            for i in range(len(self.fleche_list[12:])):                diff = abs(center_analysed - self.fleche_list[12 + i].x)                # print("diff {} on {}".format(diff, fleche_id))                if(diff < THRESH_DIFF_HORIZONTAL):                    return fleche_id                fleche_id += 1        else:            fleche_id = 1            for i in range(len(self.fleche_list[:12])):                diff = abs(center_analysed - self.fleche_list[i].x)                # print("diff {} on {}".format(diff, fleche_id))                if(diff < THRESH_DIFF_HORIZONTAL):                    return fleche_id                fleche_id += 1class Position:    def __init__(self, x, y):        self.y = y        self.x = x    def setPos(self, new_x, new_y):        self.y = new_y        self.x = new_x    def __str__(self):        return "x : {}, y : {}".format(self.x, self.y)# bg = BackGamonIMG()# bg.debug()# res = bg.getFlechePlusPres(133, 'haut')# print("----------")# print(res)# img = cv2.imread("../data/test/beginning.png", 1)# cv2.imshow("img", img)# cv2.waitKey(0)